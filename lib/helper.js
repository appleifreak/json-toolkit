// Generated by CoffeeScript 1.5.0

/*
# This file provides a basic JSON object handling
*/


(function() {
  var EventEmitter, JSONHelper, fs, json, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  json = require('../main');

  _ = require('underscore');

  fs = require('fs');

  EventEmitter = require('events').EventEmitter;

  JSONHelper = (function(_super) {

    __extends(JSONHelper, _super);

    function JSONHelper(v, options) {
      var _this = this;
      this.options = _.defaults(options, {
        from_file: false,
        key_sep: ":",
        pretty_output: false,
        indent: "\t"
      });
      this.data = null;
      if (!v) {
        this.data = {};
        this.emit("ready");
      } else if (_.isString(v)) {
        if (this.options.from_file) {
          this.file = v;
          json.parseFile(v, function(err, data) {
            _this.data = data;
            if (err) {
              return _this.emit("error", err);
            } else {
              return _this.emit("ready");
            }
          });
        } else {
          try {
            this.data = json.parse(v);
            this.emit("ready");
          } catch (e) {
            this.emit("error", e);
          }
        }
      } else {
        this.data = v;
        this.emit("ready");
      }
    }

    JSONHelper.prototype.get = function(key) {
      var current, failed, keys;
      if (!key) {
        return this.data;
      }
      if (_.isString(key)) {
        keys = this._sepPath(key);
      } else if (_.isArray(key) && key.length) {
        keys = key;
      } else {
        return this.emit("error", new Error("Expecting string or array."));
      }
      current = this.data;
      failed = _.find(_.initial(keys), function(item) {
        if (_.has(current, item)) {
          return !(current = current[item]);
        } else {
          return true;
        }
      });
      if (failed) {
        return void 0;
      } else {
        return current[_.last(keys)];
      }
    };

    JSONHelper.prototype.set = function(key, val) {
      var current, failed, keys,
        _this = this;
      if (_.isString(key) && key) {
        keys = this._sepPath(key);
      } else if (_.isArray(key) && key.length) {
        keys = key;
      } else {
        return this.emit("error", new Error("Expecting string or array for key."));
      }
      current = this.data;
      failed = _.some(_.initial(keys), function(item) {
        if (!_.has(current, item)) {
          current[item] = {};
        }
        if (!_.isObject(current[item])) {
          _this.emit("error", new Error("The key `" + item + "` exists, but setting the value failed because it isn't a traversable object."));
          return true;
        }
        current = current[item];
        return false;
      });
      if (!failed) {
        current[_.last(keys)] = val;
        return this.emit("set", keys, val);
      }
    };

    JSONHelper.prototype.match = function(key) {
      var matches, one, rmatch, stars, two;
      stars = /([\\])?(\*\*?)/i;
      one = "([^" + this.options.key_sep + "]*)";
      two = "(.*)";
      matches = [];
      rmatch = function(str) {
        var a, b, c, m;
        m = stars.exec(str);
        if (!m) {
          return str;
        }
        a = str.slice(0, m.index);
        b = m[1] ? m[2] : m[2] === "*" ? one : m[2] === "**" ? two : m[0];
        c = rmatch(str.slice(m.index + m[0].length));
        return a + b + c;
      };
      if (_.isString(key)) {
        key = new RegExp("^" + (rmatch(key)) + "$");
      }
      if (!_.isRegExp(key)) {
        return this.emit("error", new Error("Expecting string or regex."));
      }
      this.each(function(v, k) {
        if (key.test(k)) {
          return matches.push(k);
        }
      });
      return matches;
    };

    JSONHelper.prototype.each = function(start, cb) {
      var r, _ref,
        _this = this;
      if (_.isFunction(start)) {
        _ref = [start, null], cb = _ref[0], start = _ref[1];
      }
      r = function(obj, base) {
        base = base ? base + _this.options.key_sep : "";
        return _.each(obj, function(v, k) {
          k = base + k;
          cb(v, k);
          if (_.isObject(v)) {
            return r(v, k);
          }
        });
      };
      return r(this.get(start));
    };

    JSONHelper.prototype.test = function(key, test) {
      var val;
      val = this.get(key);
      if (_.isString(test)) {
        return typeof val === test;
      } else if (_.isFunction(test)) {
        return test.call(null, val);
      } else if (_.isRegExp(test)) {
        return val.test(test);
      } else {
        return test === key;
      }
    };

    JSONHelper.prototype.find = function(val) {
      var key, _find,
        _this = this;
      key = null;
      _find = function(obj, base) {
        base = base ? base + _this.options.key_sep : "";
        return _.some(obj, function(item, k) {
          k = base + k;
          if (_.isEqual(val, item)) {
            return key = k;
          } else if (_.isObject(item)) {
            return _find(item, k);
          }
        });
      };
      _find(this.data);
      return key;
    };

    JSONHelper.prototype.search = function(val) {
      var keys, _find,
        _this = this;
      keys = [];
      _find = function(obj, base) {
        base = base ? base + _this.options.key_sep : "";
        return _.each(obj, function(item, key) {
          key = base + key;
          if (_.isEqual(val, item)) {
            keys.push(key);
          }
          if (_.isObject(item)) {
            return _find(item, key);
          }
        });
      };
      _find(this.data);
      return keys;
    };

    JSONHelper.prototype.save = function(file, cb) {
      var indent, _ref,
        _this = this;
      if (_.isFunction(file)) {
        _ref = [file, this.file], cb = _ref[0], file = _ref[1];
      }
      if (!file) {
        file = this.file || null;
      }
      indent = this.options.pretty_output ? this.options.indent : null;
      return json.saveJSON(this.data, file, indent, function(err) {
        if (err) {
          if (cb) {
            return cb(err);
          } else {
            return _this.emit("error", err);
          }
        } else {
          _this.file = file;
          if (cb) {
            cb();
          }
          return _this.emit("save", file);
        }
      });
    };

    JSONHelper.prototype.toPrettyString = function(indent) {
      if (indent == null) {
        indent = this.options.indent;
      }
      return json.prettify(this.data, indent);
    };

    JSONHelper.prototype.toString = function() {
      return json.stringify(this.data);
    };

    JSONHelper.prototype.toJSON = function() {
      return this.data;
    };

    JSONHelper.prototype._sepPath = function(p) {
      return _.compact(p.split(this.options.key_sep));
    };

    return JSONHelper;

  })(EventEmitter);

  module.exports = JSONHelper;

}).call(this);
